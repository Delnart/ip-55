import aiohttp
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from config import KPI_API_URL, DAYS_TRANSLATION, CLASS_TYPES, TIMEZONE
import pytz
import logging

logger = logging.getLogger(__name__)

class ScheduleAPI:
    """–ö–ª–∞—Å –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ API —Ä–æ–∑–∫–ª–∞–¥—É –ö–ü–Ü"""
    
    @staticmethod
    async def get_schedule() -> Optional[Dict[str, Any]]:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É –∑ API"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(KPI_API_URL) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data
                    else:
                        logger.error(f"API –ø–æ–≤–µ—Ä–Ω—É–≤ —Å—Ç–∞—Ç—É—Å {response.status}")
                        return None
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É –∑ API: {e}")
            return None
    
    @staticmethod
    def format_class_info(class_data: Dict[str, Any]) -> str:
        """–§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –ø–∞—Ä—É"""
        class_type = CLASS_TYPES.get(class_data.get('type', ''), class_data.get('type', ''))
        time = class_data.get('time', '')
        name = class_data.get('name', '')
        teacher = class_data.get('teacherName', '')
        place = class_data.get('place', '')
        
        info = f"{class_type} {time}\n"
        info += f"üìñ {name}\n"
        info += f"üë®‚Äçüè´ {teacher}\n"
        
        if place:
            info += f"üìç {place}\n"
        
        return info
    
    @staticmethod
    async def get_today_schedule() -> str:
        """–†–æ–∑–∫–ª–∞–¥ –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ"""
        try:
            schedule_data = await ScheduleAPI.get_schedule()
            if not schedule_data:
                return "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ä–æ–∑–∫–ª–∞–¥"
            
            # –í–∏–∑–Ω–∞—á–∞—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π –¥–µ–Ω—å —Ç–∞ —Ç–∏–∂–¥–µ–Ω—å
            kiev_tz = pytz.timezone(TIMEZONE)
            now = datetime.now(kiev_tz)
            today = now.strftime('%A')
            week_number = now.isocalendar()[1]
            
            # –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–∂–¥–µ–Ω—å (–ø–µ—Ä—à–∏–π —á–∏ –¥—Ä—É–≥–∏–π)
            week_key = 'scheduleFirstWeek' if week_number % 2 == 1 else 'scheduleSecondWeek'
            
            # –ü–µ—Ä–µ–∫–ª–∞–¥–∞—î–º–æ –Ω–∞–∑–≤—É –¥–Ω—è
            day_mapping = {
                'Monday': '–ü–Ω',
                'Tuesday': '–í–≤',
                'Wednesday': '–°—Ä',
                'Thursday': '–ß—Ç',
                'Friday': '–ü—Ç',
                'Saturday': '–°–±'
            }
            
            day_code = day_mapping.get(today)
            if not day_code:
                return "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –¥–µ–Ω—å —Ç–∏–∂–Ω—è"
            
            # –®—É–∫–∞—î–º–æ —Ä–æ–∑–∫–ª–∞–¥ –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ
            week_schedule = schedule_data.get(week_key, [])
            today_classes = None
            
            for day_data in week_schedule:
                if day_data.get('day') == day_code:
                    today_classes = day_data.get('pairs', [])
                    break
            
            if not today_classes:
                return f"üìÖ –ù–∞ —Å—å–æ–≥–æ–¥–Ω—ñ ({DAYS_TRANSLATION[day_code]}) –ø–∞—Ä –Ω–µ–º–∞—î"
            
            # –§–æ—Ä–º–∞—Ç—É—î–º–æ —Ä–æ–∑–∫–ª–∞–¥
            result = f"üìÖ –†–æ–∑–∫–ª–∞–¥ –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ ({DAYS_TRANSLATION[day_code]}):\n\n"
            
            for i, class_data in enumerate(today_classes, 1):
                result += f"{i}. {ScheduleAPI.format_class_info(class_data)}\n"
            
            return result
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ: {e}")
            return "‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É"
    
    @staticmethod
    async def get_tomorrow_schedule() -> str:
        """–†–æ–∑–∫–ª–∞–¥ –Ω–∞ –∑–∞–≤—Ç—Ä–∞"""
        try:
            schedule_data = await ScheduleAPI.get_schedule()
            if not schedule_data:
                return "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ä–æ–∑–∫–ª–∞–¥"
            
            # –í–∏–∑–Ω–∞—á–∞—î–º–æ –∑–∞–≤—Ç—Ä–∞—à–Ω—ñ–π –¥–µ–Ω—å
            kiev_tz = pytz.timezone(TIMEZONE)
            tomorrow = datetime.now(kiev_tz) + timedelta(days=1)
            tomorrow_day = tomorrow.strftime('%A')
            week_number = tomorrow.isocalendar()[1]
            
            # –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–∂–¥–µ–Ω—å
            week_key = 'scheduleFirstWeek' if week_number % 2 == 1 else 'scheduleSecondWeek'
            
            # –ü–µ—Ä–µ–∫–ª–∞–¥–∞—î–º–æ –Ω–∞–∑–≤—É –¥–Ω—è
            day_mapping = {
                'Monday': '–ü–Ω',
                'Tuesday': '–í–≤',
                'Wednesday': '–°—Ä',
                'Thursday': '–ß—Ç',
                'Friday': '–ü—Ç',
                'Saturday': '–°–±',
                'Sunday': '–°–±'  # –ù–µ–¥—ñ–ª—è -> –ø–æ–∫–∞–∑—É—î–º–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –ø–æ–Ω–µ–¥—ñ–ª–æ–∫
            }
            
            day_code = day_mapping.get(tomorrow_day)
            if not day_code:
                return "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –¥–µ–Ω—å —Ç–∏–∂–Ω—è"
            
            # –®—É–∫–∞—î–º–æ —Ä–æ–∑–∫–ª–∞–¥ –Ω–∞ –∑–∞–≤—Ç—Ä–∞
            week_schedule = schedule_data.get(week_key, [])
            tomorrow_classes = None
            
            for day_data in week_schedule:
                if day_data.get('day') == day_code:
                    tomorrow_classes = day_data.get('pairs', [])
                    break
            
            if not tomorrow_classes:
                return f"üìÖ –ù–∞ –∑–∞–≤—Ç—Ä–∞ ({DAYS_TRANSLATION[day_code]}) –ø–∞—Ä –Ω–µ–º–∞—î"
            
            # –§–æ—Ä–º–∞—Ç—É—î–º–æ —Ä–æ–∑–∫–ª–∞–¥
            result = f"üìÖ –†–æ–∑–∫–ª–∞–¥ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({DAYS_TRANSLATION[day_code]}):\n\n"
            
            for i, class_data in enumerate(tomorrow_classes, 1):
                result += f"{i}. {ScheduleAPI.format_class_info(class_data)}\n"
            
            return result
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É –Ω–∞ –∑–∞–≤—Ç—Ä–∞: {e}")
            return "‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É"
    
    @staticmethod
    async def get_week_schedule(week_offset: int = 0) -> str:
        """–†–æ–∑–∫–ª–∞–¥ –Ω–∞ —Ç–∏–∂–¥–µ–Ω—å (0 - –ø–æ—Ç–æ—á–Ω–∏–π, 1 - –Ω–∞—Å—Ç—É–ø–Ω–∏–π)"""
        try:
            schedule_data = await ScheduleAPI.get_schedule()
            if not schedule_data:
                return "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ä–æ–∑–∫–ª–∞–¥"
            
            # –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–∂–¥–µ–Ω—å
            kiev_tz = pytz.timezone(TIMEZONE)
            target_date = datetime.now(kiev_tz) + timedelta(weeks=week_offset)
            week_number = target_date.isocalendar()[1]
            
            week_key = 'scheduleFirstWeek' if week_number % 2 == 1 else 'scheduleSecondWeek'
            week_name = "–ü–æ—Ç–æ—á–Ω–∏–π —Ç–∏–∂–¥–µ–Ω—å" if week_offset == 0 else "–ù–∞—Å—Ç—É–ø–Ω–∏–π —Ç–∏–∂–¥–µ–Ω—å"
            
            week_schedule = schedule_data.get(week_key, [])
            
            if not week_schedule:
                return f"‚ùå –†–æ–∑–∫–ª–∞–¥ –Ω–∞ {week_name.lower()} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ"
            
            result = f"üìÖ {week_name}:\n\n"
            
            for day_data in week_schedule:
                day_code = day_data.get('day')
                day_name = DAYS_TRANSLATION.get(day_code, day_code)
                pairs = day_data.get('pairs', [])
                
                if pairs:
                    result += f"üìå {day_name}:\n"
                    for i, class_data in enumerate(pairs, 1):
                        result += f"{i}. {ScheduleAPI.format_class_info(class_data)}\n"
                    result += "\n"
            
            return result
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É –Ω–∞ —Ç–∏–∂–¥–µ–Ω—å: {e}")
            return "‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É"